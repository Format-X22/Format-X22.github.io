+++
title = "Rust и роботы"
date = 2024-12-24
+++

Мой первый торговый бот был написан на JavaScript. Потом мне показалось что слишком сложно и не помещается мне в голову целиком. Потому я переписал его на CoffeeScript - был когда-то популярен такой язык. Он был чрезвычайно лаконичным и в то время уже имел классы, при том что в JavaScript, на момент создания CoffeeScript, их ещё не было. Забавно что автор языка уехал в путешествие на полтора года, вернулся, а язык уже потерял популярность. Но оно не удивительно - в JavaScript завезли классы. И перетянули из кофе кучу фич, например стрелочные функции.

На момент написания язык уже умирал, но не окончательно. И мне нравился, в том числе за лаконичность. Однако, работав до этого в QIWI, один местный программист на Java сказал мне что всегда мечтал писать на Ruby. Мол Java это для работы, а вот Ruby для души. И я решил что переход на Ruby будет отличным решением. Изучил язык по интерактивной книге-сайту, а потом прочел целиком Путь Ruby - 900 страниц не крупным шрифтом. И это был кайф.

Первый прибыльный торговый робот был на Ruby. На чистом Ruby, никаких Rails, чистый язык. Впрочем, это мне не помешало использовать JRuby - Java-интерпретатор языка. Он чуть отставал от релизов основного, зато работал поверх Java и содержал многопоточность - я планировал что торги на разных парах будут отдельными потоками.

Но время шло, я успел поторговать и руками. Даже покодить смарт-контракты на Эфире - на языке Solidity. И пообучать новичков. Но то были не боты - я пытался поднять своё ICO. В 2017 году на них был бум и денег получали все кто просил. Потому что рынок рос, всё росло. И на надежде успеть на поезд пампа - люди скупали всё что релизили, не особо вчитываясь чего за проект. Главное чтобы выросло. И оно росло.

К сожалению, я не пережил крах ICO и пришлось поработать в найме. Вот тогда знания Ruby мне и помогли. А ещё админство в крупном Ruby-чате. Так мне дали проектик на приличную сумму. Но увы - всё же основной мой язык был JavaScript и дальше я начал писать на нем. А знания крипты помогло попасть в соответствующий стартап.

Время шло и я не спеша переехал на TypeScript - версию JavaScript от Microsoft. Там добавили типы и кучу всяких абстракций, вроде интерфейсов и енумов. Автор языка - тот же что и у C#. И сейчас на этом языке работает половина интернета. А ещё куча десктопных и мобильных приложений. И конечно же встроенные приложения Windows. В принципе удобно - браузер есть чуть ли не на кофеварке. Кстати, если вы купите телевизор со смарт-тв - там тоже будет это вот всё.

Последних ботов я писал на TypeScript. Но они были аналитические - с торгами на дневных свечах можно торговать и руками, не спеша. Но вот проверить гипотезу, протестировать на длинном промежутке времени, подсказать тебе сонному с утра - это дело роботов. В самых последних версиях это был NestJS - фреймворк для бекенда сайтов, который имеет в себе очень много всего и не только для сайтов. А ещё это чуть ли не стандарт для бекендового JavaScript. А точнее TypeScript. И ещё точнее - NodeJS, именно на нем, в основном, крутится серверный JS. Впрочем, несколько лет назад начали появляться конкуренты.

И всё это время, параллельно, развивался Rust. Когда-то был популярен браузер Firefox. Он даже моментом доминировал в не-корпоративной сфере и пережил многих, в топ числе победил Microsoft с их браузером. Но сейчас по сути проиграл Google с их Chrome. И вот в 2015 создатели Firefox анонсировали Rust. Язык, который должен был решить их проблему - утечки памяти. При этом оставаясь быстрым.

Долгий путь он прошел. Сейчас он совсем не принадлежит создателям Firefox и живет отдельно. Я ещё помню шутки про «давайте перепишем всё на Rust» из 2017. Где-то у меня даже есть мем-стикеры в телеграмме, с этим мемом. Добавил их ещё тогда. Тогда это казалось забавным и так шутили те кто писал на C++. Но время прошло. И теперь Rust является разрешенным языком для ядра Linux. А это почти все сервера мира, а также все Android телефоны и бытовая техника. Раньше разрешенными были только C и C++. Приемник.

Но не только низкоуровневый код.

Сейчас все браузеры умеют в WebAssembly - такая виртуальная машина, в которой можно исполнять код и что угодно рисовать в браузере. Так, к слову, работает Dart с их Flutter от Google. В них я, кстати, тоже умею. Так вот Rust способен работать и там. И на нем я видел всё - сайты в стиле React, на котором я немного писал. Кросс-платформа для запуска сайтов и на мобилах. Вариации с легким клиентом и запуском вообще на всем что умеет в веб. Фулстек-фреймворки для работы в стиле Remix. А деды-олды вспомнят ещё и Meteor. А как на счет GUI в командной строке по SSH? Не с первого дня, но туда привнесли async/await. Уверен - влияние JavaScript. И при этом есть некоторый уровень ООП. И сборка мусора без сборщика мусора. И если скомпилировалось - значит работает. И сверху к этому - скорость уровня C. Ну и бонусом - некоторые крипто-проекты имеют смарт-контракты на Rust.

Год назад JetBrains, создатели моей любимой IDE, которой я пользуюсь с 2014, уже 10 лет, неожиданно сделали IDE и для Rust. И я понял что время пришло. Язык повзрослел и пора переходить на него. В этом году я сделал это. Это не простой язык, также он сильно отличается по стилю написания кода. Не фатально, но некоторые базовые моменты приходится писать иначе. Ну и конечно borrow-чекер. Ощущение что ты затянут в латекс и 13 чертей бьют тебя плетьми не жалея сил. И при этом это больно - но приятно. Язык, который сильно тебя ограничивает. Но делает это не просто так. Он ограничивает не эффективный код - и в исполнении кода и по памяти, особенно по памяти. Отсутствие сборщика мусора заставляет давать компилятору понять когда нужно освободить память. Отсюда и новый концепт, который не существовал до этого в других языках - метки времени жизни.

И что в итоге? Сейчас я пишу анализатор, а в будущем и бот. И с таким языком можно уже доверять коду сильно больше и сильно меньше беспокоиться что ошибка внутри приведет к крупной потере денег. Я уже написал часть кода и в ней есть выгрузка торговых данных и кое-что новое - трассировка лучей. Цикл в цикле в цикле и так несколько раз. С оптимизациями - лишние итерации не делаются, и всё же там реально многоуровневый вложенный код. Так вот вычисления происходят… за 2 секунды. С запросом в базу данных, с диска. Тестирование за 5 лет, с часовыми свечами, на 6 размерностях в обе стороны. В один поток. Я конечно ещё не дописал код, но предполагаю что в конце будет… 3 секунды. Возможно 4. Это как пересесть с велосипеда на звездолет. Очень внушает.

В целом мне нравится. Конечно на старте была адская боль с тем чтобы перестроиться думать и писать по другому, но всё же, по факту, уровень безопасности на уровне компилятора внушает доверие. И теперь я смотрю в сторону того чтобы в моменте перейти на более мелкие таймфреймы, после завершения работы с крупными. Rust сможет обеспечить меня тем что мне нужно.

Наступает новая эпоха - эпоха Rust.
